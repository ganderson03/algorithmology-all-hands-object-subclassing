---
author: [Coltin Colucci, Grant Anderson, Javier Benjarno, Megan Wolfarth, Willem Bennett]
title: How is the run time affected in a vertical and horizontal subclassing hierarchy?
page-layout: full
categories: [post, objects, subclasses]
date: "2025-02-18"
date-format: long
toc: true
format:
    html:
        code-links:    
            - text: Github Repository
              icon: github
              href: https://github.com/ganderson03/algorithmology-all-hands-object-subclassing

---

*make sure to delete your below section assignment once you finish/implement your section of the document. thanks.*

Megan : Implementation

Willem : Transfering Data Tables to Report / Measurements

Coltin : Data analysis

Javier : Conclusion


## Overview

Using objects and classes in python is a great way to encapsulate both data and functionality, while being easy to implement and use. Larger implementations via object oriented programming may require subclass hierarchies with large depth and breadth. This experiment tests how depth and breadth of subclassing can affect running time of a program. The tool calculates the areas of different shapes via different subclasses and measures the time to run throughout to measure the effect of subclass layer depth. 

## Implementation

For our experiment, we set up two inheritance hierarchies to test how runtime is affected by a deep (vertical) hierarchy compared to a wide (horizontal) hierarchy. Both of these hierarchies were polygon-based, where each subclass calculated the area of a different shape. For the vertical hierarchy, each class was inherited from the class above it for a total of ten subclasses and ten levels. For the horizontal hierarchy, each class was a subclass of a single base class for one level eight wide. In order to test runtime for the vertical hierarchy, we created two classes, square and rectangle, at the top of the hierarchy, and recreated those two classes at the bottom of the hierarchy. We then instantiated those four classes and used the `time` module in the `measure_performance` function to determine the runtime for each instantiation. To test runtime for the horizontal hierarchy, we created eight subclasses, all inherited from the `Shape` base class. We then instantiated those eight classes and used the `time` module in the `measure_performance` function to determine the runtime for each instantiation.

The `measure_performance` function is the function we used to determine the runtime for classes in the horizontal and vertical hierarchies. To determine the runtime, the function ran 10,000,000 iterations for each class, using the `time` module to determine the elapsed time by subtracting the start time from the end time.

```python
def measure_performance():
    iterations = 10000000

    shapes = [
        (Square(5), "Square (Top)"),
        (Rectangle(5, 10), "Rectangle (Top)"),
        (DeepSquare(5), "Square (Bottom)"),
        (DeepRectangle(5, 10), "Rectangle (Bottom)"),
    ]

    for shape, name in shapes:
        start_time = time.time()
        for _ in range(iterations):
            _ = shape.area()
        elapsed_time = time.time() - start_time

        # Print the results
        print(f"{name}: Time for {iterations} iterations: {elapsed_time:.6f} seconds")
```

## Data 

### Horizontal Subclasses

| Class | Iterations | Run 1 | Run 2 | Run 3 |
|:-----:|:----------:|:-----:|:-----:|:-----:|
|       |            | []    | []    | []    |
|       |            | []    | []    | []    |
|       |            | []    | []    | []    |

### Verticle Subclasses

| Class | Level | Iterations | Run 1 | Run 2 | Run 3 |
|:-----:|:-----:|:----------:|:-----:|:-----:|:-----:|
|       |       |            | []    | []    | []    |
|       |       |            | []    | []    | []    |
|       |       |            | []    | []    | []    |

## Analysis

## Conclusion